---
import { render, getCollection } from 'astro:content'
import { Image } from 'astro:assets'
import BaseLayout from '@layouts/BaseLayout.astro'
import Tags from '@components/Tags.astro'
import Comments from '@components/Comments.astro'
import { sectionsConfig } from '@config/sections'
import { loadEntryByRoute } from '@utils/sectionLoader'
import { getFullFormat, useTranslations } from '@i18n/utils'
import { languageKeys, defaultLang } from '@i18n/ui'
import type { UILanguages } from '@i18n/ui'
import Gallery from '@components/Gallery.astro'
const dateFormat = getFullFormat(Astro.url);

// Types for entry data
interface BaseEntryData {
  title: string
  translation_status?: 'original' | 'translated' | 'draft' | 'partial' | 'pending'
  translation_origin?: { locale: string; id: string }
  slug?: string
}

interface BlogTalkEntry extends BaseEntryData {
  date: Date
  tags: string[]
  image?: ImageMetadata
}

interface WorkProjectCommunityEntry extends BaseEntryData {
  excerpt: string
  image: ImageMetadata
  role?: string
  responsibilities?: string
  website?: string
  gallery?: Array<{ image: ImageMetadata; alt: string }>
}

type EntryData = BlogTalkEntry | WorkProjectCommunityEntry

export async function getStaticPaths() {
  const paths: Array<{ params: { locale: UILanguages; section: string; id: string } }> = []

  for (const [_sectionKey, config] of Object.entries(sectionsConfig)) {
    const allEntries = await getCollection(config.collection)

    for (const localeKey of languageKeys) {
      const sectionRoute = config.routes[localeKey as UILanguages]
      const entriesForLocale = allEntries.filter((e) => e.id.startsWith(`${localeKey}/`))

      for (const entry of entriesForLocale) {
        const fileCleanId = entry.id.replace(/^(en|es)\//, '')
        const entrySlug = (entry.data as BaseEntryData).slug || fileCleanId
        paths.push({ params: { locale: localeKey as UILanguages, section: sectionRoute, id: entrySlug } })
      }
    }
  }

  return paths
}

// Parse route parameters
const { locale, section, id } = Astro.params as { locale: UILanguages; section: string; id: string }
const t = useTranslations(locale)

// Load entry by route
let loaded = await loadEntryByRoute(section, locale, id)

// State for translation/untranslated notices
interface PageState {
  entry: any
  config: typeof sectionsConfig[keyof typeof sectionsConfig]
  isUntranslated: boolean
  isTranslationDraft: boolean
  translationOriginLocale: UILanguages | null
  cleanId: string
  canonicalUrl: string
}

let state: PageState

if (!loaded) {
  // Try to detect if section slug belongs to another locale and find the entry
  let fallbackConfig: typeof sectionsConfig[keyof typeof sectionsConfig] | null = null
  let fallbackLocale: UILanguages | null = null

  for (const [_key, cfg] of Object.entries(sectionsConfig)) {
    for (const lk of languageKeys) {
      if (cfg.routes[lk as UILanguages] === section) {
        fallbackConfig = cfg
        fallbackLocale = lk as UILanguages
        break
      }
    }
    if (fallbackConfig) break
  }

  if (fallbackConfig && fallbackLocale) {
    const entries = await getCollection(fallbackConfig.collection)

    // Check if entry exists in requested locale
    const entryInCurrentLocale = entries.find((e) => {
      const cleanId = e.id.replace(/^(en|es)\//, '')
      const slug = (e.data as BaseEntryData).slug || cleanId
      return e.id.startsWith(`${locale}/`) && slug === id
    })

    if (entryInCurrentLocale) {
      const targetRoute = fallbackConfig.routes[locale]
      return new Response(null, { status: 301, headers: { Location: `/${locale}/${targetRoute}/${id}` } })
    }

    // Check if entry exists in fallback locale (show with untranslated notice)
    const entryInFallbackLocale = entries.find((e) => {
      const cleanId = e.id.replace(/^(en|es)\//, '')
      const slug = (e.data as BaseEntryData).slug || cleanId
      return e.id.startsWith(`${fallbackLocale}/`) && slug === id
    })

    if (entryInFallbackLocale) {
      const cleanId = entryInFallbackLocale.id.replace(/^(en|es)\//, '')
      state = {
        entry: entryInFallbackLocale,
        config: fallbackConfig,
        isUntranslated: true,
        isTranslationDraft: false,
        translationOriginLocale: fallbackLocale,
        cleanId,
        canonicalUrl: `https://secorto.com/${fallbackLocale}/${fallbackConfig.routes[fallbackLocale]}/${cleanId}`
      }
    } else {
      return new Response('Not found', { status: 404 })
    }
  } else {
    return new Response('Not found', { status: 404 })
  }
} else {
  // Entry loaded successfully
  const cleanId = loaded.entry.id.replace(/^(en|es)\//, '')
  const entryData = loaded.entry.data as BaseEntryData
  const translationStatus = entryData.translation_status

  // Check if this is a draft/partial/pending translation
  const isTranslationDraft = Boolean(translationStatus && translationStatus !== 'translated' && translationStatus !== 'original')
  let translationOriginLocale: UILanguages | null = null
  let translationOriginId = cleanId

  if (isTranslationDraft && entryData.translation_origin) {
    translationOriginLocale = entryData.translation_origin.locale as UILanguages
    translationOriginId = entryData.translation_origin.id
  }

  const canonicalUrl = isTranslationDraft && translationOriginLocale
    ? `https://secorto.com/${translationOriginLocale}/${loaded.config.routes[translationOriginLocale as UILanguages]}/${translationOriginId}`
    : `https://secorto.com/${locale}/${loaded.config.routes[locale]}/${cleanId}`

  state = {
    entry: loaded.entry,
    config: loaded.config,
    isUntranslated: false,
    isTranslationDraft,
    translationOriginLocale,
    cleanId,
    canonicalUrl
  }
}

// Get available locales for hreflang alternates
const allEntries = await getCollection(state.config.collection)
const availableLocales = languageKeys.filter((lk) => allEntries.some((e) => e.id === `${lk}/${state.cleanId}`))

const { Content } = await render(state.entry)
const pageTitle = state.entry.data.title || t(state.config.translationKey)
const routeSlug = state.config.routes[locale]

// Build final canonical URL if draft has origin
const finalCanonicalUrl = state.isTranslationDraft && state.translationOriginLocale && state.entry.data.translation_origin
  ? `https://secorto.com/${state.translationOriginLocale}/${state.config.routes[state.translationOriginLocale]}/${state.entry.data.translation_origin.id}`
  : state.canonicalUrl
---
<head>
  <meta charset="utf-8" />
  <link rel="canonical" href={finalCanonicalUrl} />
  {(state.isUntranslated || state.isTranslationDraft) && <meta name="robots" content="noindex" />}
  {availableLocales.map((lk) => (
    <link rel="alternate" hreflang={lk} href={`https://secorto.com/${lk}/${state.config.routes[lk as UILanguages]}/${state.cleanId}`} />
  ))}
  <link rel="alternate" hreflang="x-default" href={`https://secorto.com/${defaultLang}/${state.config.routes[defaultLang as UILanguages]}/${state.cleanId}`} />
</head>

<BaseLayout pageTitle={pageTitle}>
  {state.isUntranslated && (
    <div class="untranslated-notice" role="status">
      <p>{t('post.untranslated_notice')}</p>
      <a href={`/${state.translationOriginLocale}/${state.config.routes[state.translationOriginLocale as UILanguages]}/${state.cleanId}`}>{t('post.view_original')}</a>
    </div>
  )}
  {state.isTranslationDraft && (
    <div class="untranslated-notice" role="status">
      <p>{t('post.translation_draft_notice')}</p>
      {state.translationOriginLocale ? (
        <a href={`/${state.translationOriginLocale}/${state.config.routes[state.translationOriginLocale as UILanguages]}/${state.entry.data.translation_origin?.id || state.cleanId}`}>{t('post.view_original')}</a>
      ) : (
        <a href={`/${locale}/${state.config.routes[locale]}/${state.cleanId}`}>{t('post.view_original')}</a>
      )}
    </div>
  )}
  {state.config.hasTags && state.entry.data.tags && (
    <Tags route={`/${locale}/${routeSlug}/tags/`} tags={state.entry.data.tags} />
  )}

  {state.entry.data.date && <p>{dateFormat.format(state.entry.data.date)}</p>}

  {state.entry.data.image && (
    typeof state.entry.data.image === 'string' ? (
      <img src={state.entry.data.image} alt="featured image" />
    ) : (
      <Image src={state.entry.data.image} alt="featured image" />
    )
  )}

  {(state.entry.data?.role || state.entry.data?.responsibilities) && (
    <section class="entry-metadata">
      <dl>
        {state.entry.data?.role && (
          <>
            <dt>{t('post.role')}</dt><dd>{state.entry.data.role}</dd>
          </>
        )}
        {state.entry.data?.responsibilities && (
          <>
            <dt>{t('post.responsibilities')}</dt><dd>{state.entry.data.responsibilities}</dd>
          </>
        )}
      </dl>
    </section>
  )}

  {(state.entry.data?.excerpt) && (
    <p><em>{state.entry.data.excerpt}</em></p>
  )}
  {(state.entry.data?.website) && (
    <a href={state.entry.data.website}>{t('post.website')}</a>
  )}

  <Content />
  {state.entry.data.gallery &&
    <Gallery items={state.entry.data.gallery}/>
  }

  <Comments />
</BaseLayout>
