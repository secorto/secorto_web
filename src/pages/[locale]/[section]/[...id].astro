---
import { render, getCollection } from 'astro:content'
import { Image } from 'astro:assets'
import BaseLayout from '@layouts/BaseLayout.astro'
import Tags from '@components/Tags.astro'
import Comments from '@components/Comments.astro'
import { getEntriesPaths } from '@utils/paths'
import { sectionsConfig } from '@config/sections'
import { loadEntryByRoute } from '@utils/sectionLoader'
import { useTranslations } from '@i18n/utils'
import { languageKeys, defaultLang } from '@i18n/ui'
import type { UILanguages } from '@i18n/ui'

export async function getStaticPaths() {
  const paths: any[] = []
  // Para cada sección configurada, obtener sus entradas
  for (const [_sectionKey, config] of Object.entries(sectionsConfig)) {
    // Obtener todos los entries de la colección
    const allEntriesInCollection = await getCollection(config.collection as any) as any[]

    // Generar paths SOLO para entradas que existen en cada locale
    for (const localeKey of languageKeys) {
      const sectionRoute = config.routes[localeKey as UILanguages]
      const entriesForLocale = allEntriesInCollection.filter((e: any) => e.id.startsWith(`${localeKey}/`))

      for (const entry of entriesForLocale) {
        const fileCleanId = entry.id.replace(/^(en|es)\//, '')
        const entrySlug = (entry.data as any).slug || fileCleanId
        paths.push({ params: { locale: localeKey, section: sectionRoute, id: entrySlug } })
      }
    }
  }

  // Devolver el array de paths que Astro espera (sin fallback)
  return paths
}

const { locale, section, id } = Astro.params
const t = useTranslations(locale as UILanguages)

// Cargar la entrada basada en section slug / locale / id
let loaded = await loadEntryByRoute(section, locale as UILanguages, id)

let isUntranslated = false
let originLocale: UILanguages | null = null
let isTranslationDraft = false
let translationOrigin: { locale: UILanguages; id: string } | null = null

if (!loaded) {
  // Intentar detectar si `section` es el slug en otro idioma (por ejemplo 'trabajo')
  // y redirigir al slug correcto para el locale actual o al locale original que contiene la entrada.
  let candidate: any = null
  let originLocale: UILanguages | null = null
  for (const [_key, cfg] of Object.entries(sectionsConfig)) {
    for (const lk of languageKeys) {
      if (cfg.routes[lk as UILanguages] === section) {
        candidate = cfg
        originLocale = lk as UILanguages
        break
      }
    }
    if (candidate) break
  }

  if (candidate) {
    const collectionName = candidate.collection as any
    const entries = await getCollection(collectionName) as any[]
    // ¿Existe la entrada en el locale solicitado?
    const entryForCurrent = entries.find((e: any) => {
      const fileCleanId = e.id.replace(/^(en|es)\//, '')
      const entrySlug = e.data.slug || fileCleanId
      return e.id.startsWith(`${locale}/`) && entrySlug === id
    })
    if (entryForCurrent) {
      const targetRoute = candidate.routes[locale as UILanguages]
      return new Response(null, { status: 301, headers: { Location: `/${locale}/${targetRoute}/${id}` } })
    }
    // ¿Existe la entrada en el locale original donde se encontró el slug?
    if (originLocale) {
      const entryForOrigin = entries.find((e: any) => {
        const fileCleanId = e.id.replace(/^(en|es)\//, '')
        const entrySlug = e.data.slug || fileCleanId
        return e.id.startsWith(`${originLocale}/`) && entrySlug === id
      })
      if (entryForOrigin) {
        // En lugar de redirigir, mostramos la entrada original con un aviso de "no traducido"
        loaded = { config: candidate, entry: entryForOrigin }
        isUntranslated = true
        // Mantener originLocale para canonical
        originLocale = originLocale
      }
    }
  }

  if (!loaded) {
    return new Response('Not found', { status: 404 })
  }
}

const { config, entry } = loaded
// calcular cleanId desde entry.id
const cleanId = entry.id.replace(/^(en|es)\//, '')
// si mostramos contenido original desde otro locale, usar esa URL como canonical
const canonicalLocale = isUntranslated && originLocale ? originLocale : locale
const canonicalRoute = config.routes[canonicalLocale as UILanguages]
const canonicalUrl = `https://secorto.com/${canonicalLocale}/${canonicalRoute}/${cleanId}`

// If the loaded entry itself declares a translation_status (draft/partial/pending)
if (entry && (entry.data as any).translation_status && (entry.data as any).translation_status !== 'translated') {
  // treat as translation draft: show the draft notice, set canonical to origin
  isTranslationDraft = true
  const origin = (entry.data as any).translation_origin
  if (origin && origin.locale && origin.id) {
    translationOrigin = { locale: origin.locale as UILanguages, id: origin.id }
    // override canonical info
    const origCfg = config // assume same section mapping; if different, try to find by route later
    const origRoute = origCfg.routes[translationOrigin.locale as UILanguages]
    // build canonical to the origin locale and id
    const origCanonicalUrl = `https://secorto.com/${translationOrigin.locale}/${origRoute}/${translationOrigin.id}`
    // overwrite canonicalUrl variable used in head
    // Note: canonicalUrl is const; so we'll use a separate variable below when rendering head
  }
}

// determinar en qué locales existe esta entrada para generar hreflang alternates
const collectionName = config.collection as any
const allEntries = await getCollection(collectionName) as any[]
const availableLocales = languageKeys.filter((lk) => allEntries.some((e: any) => e.id === `${lk}/${cleanId}`))
const { Content } = await render(entry)
const pageTitle = entry.data.title || t(config.translationKey)
const routeSlug = config.routes[locale as UILanguages]
---
<head>
  <meta charset="utf-8" />
  <link rel="canonical" href={isTranslationDraft && translationOrigin ? `https://secorto.com/${translationOrigin.locale}/${config.routes[translationOrigin.locale as UILanguages]}/${translationOrigin.id}` : canonicalUrl} />
  {(isUntranslated || isTranslationDraft) && <meta name="robots" content="noindex" />}
  {/* hreflang alternates: solo para locales donde exista la entrada */}
  {availableLocales.map((lk) => (
    <link rel="alternate" hreflang={lk} href={`https://secorto.com/${lk}/${config.routes[lk as UILanguages]}/${cleanId}`} />
  ))}
  {/* x-default apuntando al idioma por defecto */}
  <link rel="alternate" hreflang="x-default" href={`https://secorto.com/${defaultLang}/${config.routes[defaultLang as UILanguages]}/${cleanId}`} />
</head>

<BaseLayout pageTitle={pageTitle}>
  {isUntranslated && (
    <div class="untranslated-notice" role="status">
  <p>{t('post.untranslated_notice')}</p>
      <a href={`/${canonicalLocale}/${canonicalRoute}/${cleanId}`}>{t('post.view_original')}</a>
    </div>
  )}
  {isTranslationDraft && (
    <div class="untranslated-notice" role="status">
      <p>{t('post.translation_draft_notice')}</p>
      {translationOrigin ? (
        <a href={`/${translationOrigin.locale}/${config.routes[translationOrigin.locale as UILanguages]}/${translationOrigin.id}`}>{t('post.view_original')}</a>
      ) : (
        <a href={`/${canonicalLocale}/${canonicalRoute}/${cleanId}`}>{t('post.view_original')}</a>
      )}
    </div>
  )}
  {config.hasTags && entry.data.tags && (
    <Tags route={`/${locale}/${routeSlug}/tags/`} tags={entry.data.tags} />
  )}

  {entry.data.date && <p>{String(entry.data.date)}</p>}

  {entry.data.image && (
    // If the image frontmatter is an object (ImageMetadata), use the Astro Image component.
    // Otherwise assume it's a string URL and render a normal <img>.
    typeof entry.data.image === 'string' ? (
      <img src={entry.data.image} alt="featured image" />
    ) : (
      <Image src={entry.data.image} alt="featured image" />
    )
  )}

  <Content />

  <Comments />
</BaseLayout>
