---
import { render, getCollection } from 'astro:content'
import { Image } from 'astro:assets'
import BaseLayout from '@layouts/BaseLayout.astro'
import Tags from '@components/Tags.astro'
import Comments from '@components/Comments.astro'
import { getEntriesPaths } from '@utils/paths'
import { sectionsConfig } from '@config/sections'
import { loadEntryByRoute } from '@utils/sectionLoader'
import { useTranslations } from '@i18n/utils'
import { languageKeys } from '@i18n/ui'
import type { UILanguages } from '@i18n/ui'

export async function getStaticPaths() {
  const paths: any[] = []
  // Para cada sección configurada, obtener sus entradas
  for (const [_key, config] of Object.entries(sectionsConfig)) {
    const entries = await getEntriesPaths(config.collection as any)
    for (const e of entries) {
      const locale = e.params.locale as UILanguages
      const route = config.routes[locale]
      paths.push({ params: { locale, section: route, id: e.params.id } })
    }
  }

  // Devolver el array de paths que Astro espera (sin fallback)
  return paths
}

const { locale, section, id } = Astro.params
const t = useTranslations(locale as UILanguages)

// Cargar la entrada basada en section slug / locale / id
let loaded = await loadEntryByRoute(section, locale as UILanguages, id)

let isUntranslated = false
let originLocale: UILanguages | null = null

if (!loaded) {
  // Intentar detectar si `section` es el slug en otro idioma (por ejemplo 'trabajo')
  // y redirigir al slug correcto para el locale actual o al locale original que contiene la entrada.
  let candidate: any = null
  let originLocale: UILanguages | null = null
  for (const [_key, cfg] of Object.entries(sectionsConfig)) {
    for (const lk of languageKeys) {
      if (cfg.routes[lk as UILanguages] === section) {
        candidate = cfg
        originLocale = lk as UILanguages
        break
      }
    }
    if (candidate) break
  }

  if (candidate) {
    const collectionName = candidate.collection as any
    const entries = await getCollection(collectionName) as any[]
    // ¿Existe la entrada en el locale solicitado?
    const entryForCurrent = entries.find((e: any) => e.id === `${locale}/${id}`)
    if (entryForCurrent) {
      const targetRoute = candidate.routes[locale as UILanguages]
      return new Response(null, { status: 301, headers: { Location: `/${locale}/${targetRoute}/${id}` } })
    }
    // ¿Existe la entrada en el locale original donde se encontró el slug?
    if (originLocale) {
      const entryForOrigin = entries.find((e: any) => e.id === `${originLocale}/${id}`)
      if (entryForOrigin) {
        // En lugar de redirigir, mostramos la entrada original con un aviso de "no traducido"
        loaded = { config: candidate, entry: entryForOrigin }
        isUntranslated = true
        // Mantener originLocale para canonical
        originLocale = originLocale
      }
    }
  }

  if (!loaded) {
    return new Response('Not found', { status: 404 })
  }
}

const { config, entry } = loaded
// calcular cleanId desde entry.id
const cleanId = entry.id.replace(/^(en|es)\//, '')
// si mostramos contenido original desde otro locale, usar esa URL como canonical
const canonicalLocale = isUntranslated && originLocale ? originLocale : locale
const canonicalRoute = config.routes[canonicalLocale as UILanguages]
const canonicalUrl = `https://secorto.com/${canonicalLocale}/${canonicalRoute}/${cleanId}`
const { Content } = await render(entry)
const pageTitle = entry.data.title || t(config.translationKey)
const routeSlug = config.routes[locale as UILanguages]
---
<head>
  <link rel="canonical" href={canonicalUrl} />
  {isUntranslated && <meta name="robots" content="noindex" />}
</head>

<BaseLayout pageTitle={pageTitle}>
  {isUntranslated && (
    <div class="untranslated-notice" role="status">
  <p>{t('post.untranslated_notice')}</p>
      <a href={`/${canonicalLocale}/${canonicalRoute}/${cleanId}`}>{t('post.view_original')}</a>
    </div>
  )}
  {config.hasTags && entry.data.tags && (
    <Tags route={`/${locale}/${routeSlug}/tags/`} tags={entry.data.tags} />
  )}

  {entry.data.date && <p>{String(entry.data.date)}</p>}

  {entry.data.image && (
    // If the image frontmatter is an object (ImageMetadata), use the Astro Image component.
    // Otherwise assume it's a string URL and render a normal <img>.
    typeof entry.data.image === 'string' ? (
      <img src={entry.data.image} alt="featured image" />
    ) : (
      <Image src={entry.data.image} alt="featured image" />
    )
  )}

  <Content />

  <Comments />
</BaseLayout>
